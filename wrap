#!/usr/bin/perl -w
#  
# Wrap Package v1.0 - a program to collate and arrange files.  It 
# automates file collection, processing (in particular, the addition of 
# copyright notices) and packaging. 
#  
# Copyright (C) 1998 Andrew Cooke  (Jara Software) 
#  
# Comments to andrew@acooke.org
#  
# This program is free software; you can redistribute it and/or modify 
# it under the terms of the GNU General Public License as published by 
# the Free Software Foundation; either version 2 of the License, or (at 
# your option) any later version. 
#  
# This program is distributed in the hope that it will be useful, but 
# WITHOUT ANY WARRANTY; without even the implied warranty of 
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
# General Public License for more details. 
#  
# You should have received a copy of the GNU General Public License 
# along with this program; if not, write to the Free Software 
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 
# USA 
#  
# These conditions also apply to any other files distributed with this 
# program. 
#  

&setConstants ;



# the following may need changing for local conditions --------------

# the temporary directory - files are collected in a subdirectory
# note that files in TMPDIR will be silently deleted
$TMPDIR = "/tmp" ;

# this is the table that contains information on how to add comments
# to different formats
# format is:
# addFormat(<file extensions>, <start comment>, <end comment>,
#           <number of lines to skip before comment>,
#           <non-zero if comment markers needed every line>,
#           <non-zero if comment should be added>, <description>)
&addFormat( "pl",    "#",    "",    1, 1, 1, "Perl source" ) ;
&addFormat( "java",  "/*",   "*/",  0, 0, 1, "Java source" ) ;
&addFormat( "JAVA",  "//",   "",    0, 1, 1, "Java source, single line" ) ;
&addFormat( "egg",   "{",    "}",   0, 1, 1, "Egg source" ) ;
&addFormat( "sml",   "(*",   "*)",  0, 0, 1, "SML source" ) ;
&addFormat( "ml",    "(*",   "*)",  0, 0, 1, "ML source" ) ;
&addFormat( "h",     "/*",   "*/",  0, 0, 1, "C header" ) ;
&addFormat( "c",     "/*",   "*/",  0, 0, 1, "C source" ) ;
&addFormat( "cc",    "/*",   "*/",  0, 0, 1, "C++ source" ) ;
# html 3 line skip for xml and doctype declarations
&addFormat( "html",  "<!--", "-->", 3, 0, 1, "HTML source" ) ;
&addFormat( "NONE",  "",     "",    0, 0, 0, "Don't alter" ) ;
&addFormat( "gif",   "",     "",    0, 0, 0, "Don't alter image file" ) ;
&addFormat( "class", "",     "",    0, 0, 0, "Don't alter class file" ) ;
&addFormat( "py",    "#",    "",    0, 1, 1, "Python source" ) ;
&addFormat( "lhs",   "%",    "",    0, 1, 1, "Literate Haskell source" ) ;
&addFormat( "hs",    "{-",   "-}",  0, 0, 1, "Haskell source" ) ;
&addFormat( "tex",   "%",    "",    0, 1, 1, "Tex/Latex source" ) ;

# default filename
$NAME = "archive" ;

# default extra filename (none)
$NEW_HEAD = "./" ;

# default head (path to find subsequent files)
$HEAD = "./" ;

# number of seconds to pause before zapping whole directories...
# (non-zero for the wise :-)
$DELAY_TIME = 0 ;

# nothing below here should need changing ----------------------------



# this was never meant to be elegant - it's a perl script! ;)

# read args

if ( $#ARGV == 0 ) {
	$manifest = shift( @ARGV ) ;
} else {
	$manifest = "manifest" ;
}
if (! ( -e $manifest && -f $manifest )) { 
	die "the list of files must be a file" ; 
}
print "reading file list from $manifest\n" ;


# make temp dir

if (! ( -e $TMPDIR && -d $TMPDIR )) {
	die "the temp dir must be a directory - edit this source" ;
}
$TMP = $TMPDIR . "/wrap" ;
if ( -e $TMP ) { deleteDir( $TMP ) ; }
mkdir( $TMP, 0777 );


# process list

open ( MAN, "<$manifest" ) ;
while (<MAN>){
	chop ;
	$ok = 0 ;

	# skip any comments
	if (! $ok ) {
		if ( /^\s*$/ || /^\s*#/ ) {
			 $ok = 1 ;
		 }
	}

	# process commands
	if (! $ok ) {
		if ( /^\s*COMMENT\s+([\w\$\-\/\.]+)\s*$/ ) {
			$COMMENT = $1 ;
			if (! ( -e $COMMENT && -f $COMMENT )) {
				print "comment file $COMMENT does not exist\n" ;
			}
			$ok = 1 ;
		} elsif ( /^\s*HEAD\s+([\w\$\-\/\.]+)\s*$/ ) {
			$HEAD = $1 ;
			if (! ( -e $HEAD && -d $HEAD )) {
				print "source head $HEAD does not exist\n" ;
			}
			$ok = 1 ;
		} elsif ( /^\s*NAME\s+([\w\$\-]+)\s*$/ ) {
			$NAME = $1 ;
			$ok = 1 ;
		} elsif ( /^\s*NEW_HEAD\s+([\w\$\-\/]+)\s*$/ ) {
			$NEW_HEAD = $1 ;
			$ok = 1 ;
		}
	}

	# process a file
	if (! $ok ) {
		$name = "" ;
		$ext = "" ;
		if ( /^\s*([\w\$\-\/\.]+)\s+([\w\$\-]+)\s*$/ ) {
			$ext = $2 ;
			$name = $1 ;
		} elsif ( /^\s*([\w\$\-\/]+\.)([\w\$\-]+)\s*$/ ) {
			$ext = $2 ;
			$name = $1 . $ext ;
		}
		if ( $name ) {
			&process( $name, $ext ) ;
			$ok = 1 ;
		}
	}

	# process a directory
	if (! $ok ) {
		$name = "" ;
		if ( /^\s*(\.?[\w\$\-\/])\s*$/ ) {
			$name = $1 ;
			print $name ;
		        &processDir( $name ) ;
		        $ok = 1 ;
	}
	}

}
close( OUT ) ;


# generate and compress tar file
chop( $cwd = `pwd` ) ;

$tar = $cwd . "/" . $NAME . ".tar" ;
$zip = $cwd . "/" . $NAME . ".zip" ;
print "making $tar and $zip\n" ;
if ( -e $tar ) { unlink $tar ; }
if ( -e $zip ) { unlink $zip ; }
chdir( $TMP ) ;
printAdvert( ) ; # subversive!
system( "tar -cvf $tar *" ) ;
system( "zip $zip -r *" ) ;
chdir( $cwd ) ;

$gz = $tar . ".gz" ;
print "compressing to create $gz\n" ;
if ( -e $gz ) { unlink $gz ; }
system( "gzip $tar" ) ;
deleteDir( $TMP ) ;

$compact = $cwd . "/" . $NAME . ".tgz" ;
print "renaming to $compact\n" ;
if ( -e $compact ) { unlink $compact ; }
system( "mv $gz $compact" ) ;

print "done\n" ;



# subroutines below -------------------------------------------


# add a format description
sub addFormat{
	local( $ext, @desc ) = @_ ;
	$FORMAT{$ext} = \@desc ;
	print "added format for $FORMAT{$ext}[$FMT_DESC]\n" ;
}


# process a file
sub process{
	local( $name, $ext ) = @_ ;
	if (! $FORMAT{$ext} ) {
		print "no format for extension $ext ($name)\n" ;
		$fmt = $FORMAT{"NONE"} ;
	} else {
		$fmt = $FORMAT{$ext} ;
	}
	$src = $HEAD . "/" . $name ;
	$dest = $TMP . "/" . $NEW_HEAD . "/" . $name ;
	&makePath( $dest ) ;
	if (! ( -e $src && -f $src )) {
		print "cannot find $src\n" ;
	} else {
		$desc = $$fmt[$FMT_DESC] ;
		$start = $$fmt[$FMT_START] ;
		$end = $$fmt[$FMT_END] ;
		$skip = $$fmt[$FMT_SKIP] ;
		$every = $$fmt[$FMT_EVERY] ;
		$doComment = $$fmt[$FMT_ADD] ;
		print "copying $src to $dest as $$fmt[$FMT_DESC]\n" ;
		print "$$fmt[$FMT_DESC] : $src\n" ;
		open( IN, "<$src" ) || die "couldn't open $src" ;
		open( OUT, ">$dest" ) || die "couldn't open $dest" ;
		$count = 0 ;
		while( <IN> ){
			$line = $_ ;
			if ( $count == $skip && $doComment ) { 
				print "adding comment file\n" ;
				if (! $every ) { print OUT "$start\n" ; }
				open( COMMENT, "<$COMMENT" ) ;
				while( <COMMENT> ) {
					if ( $every ) {
						chop ;
						print OUT "$start $_ $end\n" ;
					} else {
						print OUT ;
					}
				}
				if (! $every ) { print OUT "$end\n" ; }
				close( COMMENT ) ;
			}
			print OUT $line ;
			++$count ;
		}
	}
}


# process a directory (recursive!)
sub processDir{
	local( $path ) = @_ ;
	local( $fullPath, $name, $ext, $dir, $fullDir ) ;
	$fullPath = $HEAD . "/" . $path ;
	if ( -e $fullPath && -d $fullPath && $fullPath !~ /CVS/ ) {
		open( $fullPath, "ls -1 $fullPath |" ) || 
			die "cannot look at directory $path" ;
		while( <$fullPath> ) {
			chop ;
			$name = "" ;
			$ext = "" ;
			if ( /^\s*([\w\$\-\/]+\.)([\w\$\-]+)\s*$/ ) {
				$ext = $2 ;
				$name = $1 . $ext ;
			} elsif ( /^\s*([\w\$\-\/]+)\s*$/ ) {
				$ext = "NONE" ;
				$name = $1 ;
			}
			if ( $name ) {
				$dir = $path . "/" . $name ;
				$fullDir = $fullPath . "/" . $name ;
				if ( -d $fullDir ) {
					&processDir( $dir ) ;
				} else {
					&process( $dir, $ext ) ;
				}
			}
		}
	}
}


# generate the path for a file
sub makePath{
	local( $file ) = @_ ;
	if ( $file =~ /^\s*([\w\$\-]*)([\w\$\-\.\/]*?)[\w\$\-\.]*\s*$/ ) {
		$start = $1 ;
		$file = $2 ; # drop final name
		@dir = split( '/', $file ) ;
		if (! $start ) { $start = "/" ; }
		if (! -e $start ) { mkdir( $start, 0777 ) ; }
		foreach $step ( @dir ) {
                        print "adding $step to $start\n" ;
			$start = $start . "/" . $step ;
			if (! -e $start ) {
                                print "mkdir...\n" ;
                                mkdir( $start, 0777 ) ;
                        }
		}
	}
}


# set global constant
sub setConstants{
	$FMT_START = 0 ;
	$FMT_END = 1 ;
	$FMT_SKIP = 2 ;
	$FMT_EVERY = 3 ;
	$FMT_ADD = 4 ;
	$FMT_DESC = 5 ;
}


# delete a directory (and contents)
sub deleteDir{
	local( $name ) = @_ ;
	if ( -e $name && -d $name ){
		print "deleting $name...\n" ;
		$count = $DELAY_TIME ;
		while( $count > 0 ){
			print "...in $count second(s)\n" ;
			sleep( 1 ) ;
			--$count ;
		}
		system( "rm -r $name" ) ;
		print "...done\n" ;
	} else {
		print "$name is not a directory, so cannot delete\n" ;
	}
}

# print an advert
sub printAdvert{
	local( $adName ) ;
	$adName = "advert" ;
	if (! -e $adName ) {
		print "putting a small ad in $adName\n" ;
		open( AD, "> $adName" ) ;
		print AD "This archive was generated by \"wrap\" (c) 1998 Andrew Cooke\nFor more info, please see\nhttp://www.andrewcooke.free-online.co.uk/jara/wrap/index.html\n" ;
		close( AD ) ;
	}
}
